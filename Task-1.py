# -*- coding: utf-8 -*-
"""Task-1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X_Qpt4ShG02h5YytJLsadjpeBFyuFIRH
"""

import pandas as pd

df = pd.read_csv('/content/drive/MyDrive/Dataset/World Bank/API_SP.POP.TOTL_DS2_en_csv_v2_34.csv', skiprows=3)
metadata_country = pd.read_csv('/content/drive/MyDrive/Dataset/World Bank/Metadata_Country_API_SP.POP.TOTL_DS2_en_csv_v2_34.csv')
metadata_indicator = pd.read_csv('/content/drive/MyDrive/Dataset/World Bank/Metadata_Indicator_API_SP.POP.TOTL_DS2_en_csv_v2_34.csv')

df.info()

metadata_country.info()

metadata_indicator.info()

# Delete parcing row
df = df.drop(columns=['Unnamed: 69'])
metadata_country = metadata_country.drop(columns=['Unnamed: 5'])
metadata_indicator = metadata_indicator.drop(columns=['Unnamed: 4'])

df.head()

"""Although aggregate entities are not explicitly labeled in the main dataset, the World Bank provides entity definitions in the country metadata. By filtering out records where the region is marked as “Aggregates,” we ensure that only valid country-level observations are included in the analysis."""

metadata_country.head()

"""From Metadata_Country file we know that country-level entities can be identified by having both Region and IncomeGroup populated, while aggregate entities exhibit missing values in one or both of these columns."""

# make sure the rules before use it for filtering country
metadata_country[['Region', 'IncomeGroup']].isna().value_counts()

"""Based on the output, 215 entities have both Region and IncomeGroup defined, indicating country-level records. Additionally, 48 entities have both fields missing, which corresponds to aggregate entities. There are also 2 entities where Region is defined but IncomeGroup is missing, representing regional aggregates rather than countries."""

metadata_indicator.sample()

"""## **1. Apa Country dengan populasi terbesar?**"""

# Make rules that keep only country-level entities (exclude aggregates (in this case the aggregates is NaN) using metadata)
valid_countries = metadata_country.loc[
    metadata_country['Region'].notna()
    & metadata_country['IncomeGroup'].notna()
    ]['Country Code']

df_country= df[df['Country Code'].isin(valid_countries)] # Filtered country with the "valid_countries" as a rules
df_2024 = df_country[['Country Name', '2024']].dropna()

top10 = (df_2024.sort_values(by='2024', ascending=False).head(10))

print(df['Country Name'] == 'China')

import matplotlib.pyplot as plt

plt.figure(figsize=(10,6))
plt.bar(top10['Country Name'], top10['2024'])
plt.xticks(rotation=45, ha='right')
plt.title('Top 10 Countries by Population (2024)')
plt.ylabel('Population')
plt.xlabel('Country')
plt.tight_layout()
plt.show()

"""The three countries with the largest populations are India, China, and the United States. To provide context for this snapshot, the population levels of these countries are compared across the 2020–2024 period to observe short-term changes

## **2. Bagaimana Kondisi Ekonomi dari Negara-Negara yang memiliki populasi terbesar di dunia?**
"""

import matplotlib.pyplot as plt
import pandas as pd

top_country = ['United States', 'China', 'India']
df_top = (
    metadata_country[
        metadata_country['TableName'].isin(top_country)
    ][['TableName', 'IncomeGroup']]
)

income_order = {
    'Low income': 1,
    'Lower middle income': 2,
    'Upper middle income': 3,
    'High income': 4
}

df_top['IncomeCode'] = df_top['IncomeGroup'].map(income_order)

# plot
plt.figure(figsize=(7,5))
plt.bar(df_top['TableName'], df_top['IncomeCode'])

plt.yticks(
    list(income_order.values()),
    list(income_order.keys())
)

plt.xlabel('Country')
plt.ylabel('Income Group')
plt.title('Income Group Classification of Top Countries')
plt.tight_layout()
plt.show()

"""Although the United States, China, and India are all globally influential countries, they belong to different income groups. This highlights that global influence and economic scale do not necessarily translate into high per-capita income, underscoring the importance of income-group stratification in cross-country analyses.

## **3. Bagaimana Pertumbuhan ketiga negara tersebut dalam 4 tahun terakhir?**
"""

import numpy as np

top_country = ['United States', 'China', 'India']
years = ['2020', '2021', '2022', '2023', '2024'] # Range of Time

population_subset = (df_country[
    df_country['Country Name'].isin(top_country)]
         [['Country Name', 'Country Code'] + years])

x = np.arange(len(years))
width = 0.25

plt.figure(figsize=(10,6))

for i, country in enumerate(top_country):
  values = population_subset[population_subset['Country Name'] == country][years].values.flatten()

# Plot
  plt.bar(
      x+i * width,
      values,
      width,
      label=country
  )

plt.xticks(x + width, years)
plt.xlabel('Year')
plt.ylabel('Population')
plt.title("Top 3 Country with Largest Population (2020-2024)")
plt.legend()
plt.tight_layout()
plt.show()

"""From 2020 to 2024, India experiences steady population growth, China remains largely stable, and the United States shows moderate increases. This comparison reflects short-term population dynamics rather than long-term trends.

## **4. What is the composition of the number of countries in each income group, and does this classification change over the 2020–2024 period?**
"""

print(metadata_country['IncomeGroup'].unique())

df_base = (
    df_country[df_country['Country Code'].str.len() == 3]
    .merge(
        metadata_country[['Country Code', 'IncomeGroup']],
        on='Country Code',
        how='left'
    )
)

df_base = df_base.dropna(subset=['IncomeGroup'])

# Calculate the number of countries per income group per year
records = []
for year in years:
    counts = (
        df_base[['Country Code', 'IncomeGroup']]
        .drop_duplicates()
        .groupby('IncomeGroup')
        .size()
    )
    counts.name = year
    records.append(counts)

df_bar = pd.concat(records, axis=1).fillna(0)

# plot
plt.figure(figsize=(10,6))
df_bar.T.plot(kind='bar')

plt.xlabel('Year')
plt.ylabel('Number of Countries')
plt.title('Number of Countries by Income Group (2020–2024)')
plt.xticks(rotation=0)
plt.legend(title='Income Group')
plt.tight_layout()
plt.show()

"""The number of countries in each income group from 2020 to 2024. The counts remain constant across years, reflecting that income group classifications are treated as static metadata in this dataset rather than time-varying economic indicators. This stability provides a structural baseline for subsequent analyses comparing population and economic variables across income groups"""

df_hist = (
    df_country[
        df_country['Country Code'].str.len() == 3][['Country Code', '2024']]
        .dropna().merge(
        metadata_country[['Country Code', 'IncomeGroup']],
        on='Country Code',
        how='left'
    )
)

df_hist['2024'] = pd.to_numeric(df_hist['2024'], errors='coerce')
df_hist = df_hist.dropna(subset=['IncomeGroup', '2024'])


df_hist['IncomeGroup'].value_counts()

plt.figure(figsize=(10,6))
df_hist['log_pop_2024'] = np.log10(df_hist['2024']) # Log Transform Population

bins = np.linspace(
    df_hist['log_pop_2024'].min(),
    df_hist['log_pop_2024'].max(),
    30
)

for g in sorted(df_hist['IncomeGroup'].unique()):
    vals = df_hist.loc[df_hist['IncomeGroup'] == g, 'log_pop_2024']
    plt.hist(
        vals,
        bins=bins,
        alpha=0.45,
        label=g,
        edgecolor='black',
        linewidth=0.8
    )

plt.xlabel('Population (log10 scale, 2024)')
plt.ylabel('Number of countries')
plt.title('Population Distribution by Income Group (2024)')
plt.legend()
plt.tight_layout()
plt.show()

df_hist = (
    df_country[df_country['Country Code'].str.len() == 3]
    [['Country Code'] + years]
    .merge(
        metadata_country[['Country Code', 'IncomeGroup']],
        on='Country Code',
        how='left'
    )
)

df_hist[years] = df_hist[years].apply(pd.to_numeric, errors='coerce')

df_long = (
    df_hist
    .melt(
        id_vars=['Country Code', 'IncomeGroup'],
        value_vars=years,
        var_name='Year',
        value_name='Population'
    )
    .dropna(subset=['IncomeGroup', 'Population'])
)

